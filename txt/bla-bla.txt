The basic idea is determine what are the commands that are most widely used, then determine which of these seem longer to type or difficult to remember, and finally create aliases for these and auto-complete if necessary.

Creating an alias is not a big deal in bash, one simply appends at the end of ~/.bashrc any alias he likes (even the ones that overwrite some of the existing, what can be used to confuse the user). The alias is added in the following way: 
    alias alias_name = "what_should_it_do"
    e.g. alias pretty_list = "tree"

There is however a better way of doing the above mentioned operations. Aliases can be added to a separate file and will not mess with default .bashrc contents. Aliases from this separate file are added in case there exists a file ~/.bash_aliases (by default) or any other file, the path to which we set in the config as follows:

        if [ -f ~/utm/Diploma/.siunl_aliases ]; then
            . ~/utm/Diploma/.siunl_aliases
        fi

If a file with the given name exists and, well, IS a file then
//////////////////EDIT///////////////
the commands, functions, aliases that are defined in this file are copied or added to the list of bash commands, behavior similar to including a library in C/C++/Java.
////////////////////////////////////

Important is that even if the you have defined aliases in some_file_for_aliases or even in ~/.bashrc itself, newly defined commands will not be yet available in the your CLI. 
////////////////////EDIT//////////////////////
these need loaded. To do so, type in:
. ~/.bashrc

As far as I understood this reloads bashrc file.
//////////////////////////////////////////////

Let's explain a little what all the symbols represent in ". ~/.bashrc":

/////////////////////EDIT///////////////////////
1) . - no idea yet
2) ~ - it's the shortcut to /home/"username"
3) .bashrc - is a filename, and contrary to windows concept, any filename preceded by a "." in linux is considered a hidden file. Thus, .bashrc is a hidden file named "bashrc"
//////////////////////////////////////////////////

Added a function to create new aliases (add_alias). It takes as input two arguments and adds an alias to .siunl_aliases, then reloads the .bashrc file so that newly added alias is available right away. Also, added a function for removing aliases, takes one parameter - alias_name. Using "sed" and unalias:
        unalias -a "$1"
        sed -i '/asa/d' ~/utm/Diploma/.siunl_aliases
Afterwards it mandatorily reloads .bashrc in order to contain the updated list of commands. "unalias -a" as it seems clear from its name is the opposite of alias and what it does is removing the alias.

////////////////////////EDIT///////////////////////////////////////////
why is there used the parameter "-a" only God knows, I can only suppose it stands for alias))
/////////////////////////////////////////////////////////////////////

"sed" appears to be an awesome function that could be used for easy (khaa)
file editing, though it has loads of options and if these are set the wrong way, one could end up with an erased file. A PERFECT CANDIDATE FOR human.sh

"grep" is fine as well, allows searching. Has several options as well, combined with sed makes a powerful tool for editing files on the fly. 

Function that displays currently available custom aliases.

Worth mentioning is the fact that bash aliases can be added in place, using:
        alias some_name="bash command"
The drawback of this approach is its impersistence, the alias that has been created will be accessible only from the current tab/window of the terminal, even if one opens a new tab, the alias will not be accessible.

Despite the fact that functions appear exactly the same thing as aliases themselves from a user's point of view these are grouped/considered in a different way by the shell. 

- functions are commands. The list of all commands can be viewed calling "compgen -c"

- aliases... are aliases, and the list of these is very short, much shorter than one could imagine. The list can be obtained calling "compgen -a";

The list of all default aliases (there are only 9):

    1) alert
    2) background
    3) egrep
    4) fgrep
    5) grep
    6) l
    7) la
    8) ll
    9) ls

-------------------------------------------------------------------------
Adding search function, experimenting with auto-complete.
-------------------------------------------------------------------------

****************Determining OS version, codename, package manager and 32/64 bit

for this purpose, on ubuntu and its derivatives can be used "lsb_release -a" to get all available info regarding system, codename, bits. Same applies to ubuntu derivatives, I suppose for debian as well, as ubuntu is a derivativeof the latter. OpenSUSE also complies with that standard and allows determining system info as mentioned above. Difficulties appear when one gets to Fedora. This distribution does not allow using lsb_release, nevertheless it should have an alternative, it is: "cat /etc/fedora-release" OR "cat /etc/issue", the latter tries to display some info about kernel, unsuccessfully, it prints only the following: "Kernel \r on an \m (\l)". Thus the first option for getting fedora release name is better.

After little research and search a common solution for supposedly all linux distibutions was found: "cat /etc/os-release", displays all the info about the distro except two bits of information that are still needed for the human.sh to get setup. These are: hardware platform (32/64bits) and available package managers.
Determining hardware platform is easier than getting distro info. All distributions on which testing was done support uname command that display Linux information (not to be mistaken with linux distro). Hardware platform info is obtained as follows: "uname -i", this command returns x86_64 for 64bit systems and supposedly x86 for 32bit systems.

============NOTE==
tests are performed on:

1) elementary OS Luna (x86_64)
2) Ubuntu 14.04 LTS, Trusty Tahr (x86_64)
3) Fedora 20 (Heisenbug) (x86_64)
4) OpenSUSE 13.1 Bottle (x86_64)
5) MacOS is planned

==EOF_NOTE================

Implemented two more aliases. siunl_refresh that allows easy loading of newly added aliases into ========memory=========== and tellme.
The latter is much more interesting as it is the first step to some plain english discussion between a user and his computer. Currently two scenarios were considered:
1) tellme about os - outputs all the info about the system (name, id, id_like, pretty_name and version)
2) tellme about hardware platform - tells if the system is 32/64 bit.

Any alias that is called outputs the actual command that was used. Here's an example output for calling the first command

leshik@AsusL:~/utm/Diploma/src$ tellme about os
using "cat /etc/os-release" 

NAME="elementary OS"
VERSION="0.2 Luna"
ID="elementary OS"
ID_LIKE=ubuntu
PRETTY_NAME="elementary OS Luna"
VERSION_ID="0.2"

Further steps imply analyzing and determining best way for calling an alias, meaning that the call is short, yet explicit and easy to understand, i.e. human.sh ideology compatible.

Made first steps for implementing "is" alias, as this one could serve well requests as "is my system 32bit". 
That is where questions appear, should the word "my" be included as a parameter, or should it be not. On the other hand a very nice approach might be considering the case that there might be "my" or there might be not. If so, "tellme about os" and "tellme about my os" should return the same results.

For the current milestone ability to determine available package manager has yet to be added and for the sake of using the latter, a human.sh alias for installing software should be added, i.e. (install skype).

Talking about skype. One should know about 3rd party repositories and about other official repos that are available, yet not present in the current distro or the installed version of the distro. 
This will be another milestone.

Another important function that should get its human alias is find, it might obtain a variety of parameters which in their turn can be interpreted in several ways. Like "find mySomething", can search down the directory tree, or it can search everyehere or it can search down the tree and several steps up the tree or it can search equally several steps up and down the tree. These are problems that ought to be solved during actual implementation.

--------
Package manager detection. There is a tool that says it is universal for all UNIX-based systems. The tool can be found here: https://github.com/icy/pacapt/blob/master/pacapt#L168 and is named "pacapt". From its description it supports:

    pacman        by Arch Linux, ArchBang, Manjaro, etc.
    dpkg/apt-get  by Debian, Ubuntu, etc.
    homebrew      by Mac OS X
    macports      by Mac OS X
    yum/rpm       by Redhat, CentOS, Fedora, etc.
    portage       by Gentoo
    zypper        by OpenSUSE

Package manager detection was realized using the following chunk of code: 

        #Determine package manager
        if [ -f /usr/bin/apt-get ]; then
            _PMANAGER="APT"
        fi
        if [ -f /usr/bin/yum ]; then
            _PMANAGER="YUM"
        fi
        if [ -f /usr/bin/zypper ]; then
            _PMANAGER="ZYPPER"
        fi

Having the required information about the system and the package manager, allows installing and uninstalling software, as well as updating system and apps, refreshing the list of repos and other stuff.

-----------
Added possibility to do a full system update using "please do full update", currently only available for apt package manager. Optimized query matching, transforming all requests to lowercase.
At the moment $@ is used, this variable concatenates all arguments passed to a function using ' ' a space. 

---------------------

Auto completion is a core feature of bash because it increases considerably the speed of work, it allows tapping one key and then [TAB] to obtain the full command, which might've taken several seconds to type.

All files that are used for auto-complete function are stored in /etc/bash_completion.d/. Files are named according to the command/alias without any extension following. This way for the main command that is currently available "tellme", a file named exactly the same was created in the directory mentioned above and includes several cases that need to be considered for auto-complete to work. 
The logic is pretty straightforward. Bash stores all the words typed in a line in a variable of type array, named COMP_WORDS, this way it is possible to get current word, prev word or if needed any of the earlier ones.
For the command "tellme about my os", one can use [TAB] as soon as "tell" is typed, then once again to obtain "tellme about ". Later the function verifies what words were already input and then echoes available options, if a single or several letters are typed in then terminal will suggest only options that start with respective chars.

    if [[ ! ${COMP_WORDS[*]} =~ system ]] &&
        [[ ! ${COMP_WORDS[*]} =~ os ]] &&
        [[ ! ${COMP_WORDS[*]} =~ hardware ]] &&
        [[ ! ${COMP_WORDS[*]} =~ arch ]] &&
        [[ ${cur} == * ]]; then
        COMPREPLY=( $(compgen -W "${opts3}" -- ${cur}) )
        return 0
    fi

Code above serves for completing the command with $opts3, that is equal to a string "system os hardware arch", for this statement to be true, in the condition is verified if none of the four words were used previously and that current word is empty

Besides implementing auto-complete functionality, for the ease of development a function to siunl_admin was added, to be precise there were three of them: siunl_load_aliases, reloads all aliases that were added since last refresh; siunl_load_auto_complete, loads auto-complete files, and before doing this, it copies all the files from /src/auto-complete/ to /etc/bash_complete.d/ and then loads each of the files, since there is no

/////////////////EDIT/////////////////////////////
way to load all new files at except for reloading the system
///////////////////////////////////////////////////


%%%%  what "wc" command is, what is does? is it word count

%%%%  find $(pwd) -name "*.rb" -exec grep -l "interest" {} \; WHYY?? explain

%%%%  write about pagination, why "less -R" and not "pg"

%%%%  write about math comparison. 2 approaches and the one chosen - why?

%%%%  write how conditionals are "made" [[]], (()), [], condition

